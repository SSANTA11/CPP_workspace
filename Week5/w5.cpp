#include <iostream>
#include <string>
using namespace std;

class Circle {
private:
    int radius;

public:
    Circle() : Circle(1) {}

    Circle(int r) {
        radius = r;
        cout << "반지름 " << radius << "원 생성\n";
    }

    ~Circle() {
        cout << "반지름 " << radius << "원 소멸\n";
    }

    void setRadius(int r) {
        radius = r;
    }

    double getArea() {
        return 3.14 * radius * radius;
    }
    int getRadius() {
        return radius;
    }
};


// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 객체 배열

// 배열 이름은 주소값(다음 시간******************************************************중요*********************************************************************)// 165pg 이후....!

//int main() {
//    //Circle circleArray[3]; // 3개의 원소를 가지는 Circle 객체배열 생성. 이때 객체는 3번 반복되기 떄문에, 위 Circle클래스의 기본 생성자와 소멸자는 각각 3번 불린다.
//    //circleArray[0].setRadius(10); // 배열원소.맴버
//    //circleArray[1].setRadius(20);
//    //circleArray[2].setRadius(30);
//
//    Circle circleArray[3] = { Circle(10), Circle(), Circle(10) };
//
//    for (int i = 0; i < 3; i++) {
//        cout << "Circle" << i << "의 면적은"<<circleArray[i].getArea()<<endl;
//    }
//    Circle* p = circleArray; // 배열 이름은 주소이므로 포인터에 대입가능. 이때 배열의 이름은 첫 원소의 주소를 가르키고 있다.(참고로 배열은 연달아 있다...!)
//    for (int i = 0; i < 3; i++) { //객체 포인터로 배열원소 접근가능
//        cout << "Circle" << i << "의 면적은"<<p->getArea()<<endl; // 포인터를 증가시키면 다음 원소를 가르킴
//
//    }
//
//}
// 포인터 변수는 '주소만을 담는 변수' 이다!

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 동적 할당

// 174pg 시험 출제 관련 메모 확인 하기

//int main() {
//    cout << "입력할 정수의 개수 ";
//    int n;
//    cin >> n;
//    if (n <= 0)
//        return 0;
//    int* p = new int[n];
//    for (int i = 0; i < n; i++) {
//        cout << i + 1 << "번째 정수: ";
//        cin >> p[i];
//    }
//    int sum = 0;
//    for (int i = 0; i < n; i++) {
//        sum += p[i];
//    }
//    cout << "평균= " << sum / n << endl;
//    delete [] p; //중요************************************************************************************출제 포인트! 배열 메모리 반환!!!
//}



// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//객체배열의 동적할당(179pg)
//int main() {
//    int radius;
//    while (true) {
//        cout << "반지름(종료하려면 음수): ";
//        cin >> radius;
//        Circle* p;
//        if (radius < 0)
//            break;
//        else if (radius == 0)
//            p = new Circle;
//        else
//            p = new Circle(radius);
//        cout << "면적= " << p -> getArea() << endl;
//
//        delete p;
//    }
//}


// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// 객체 배열의 동적 생성 및 반환
// 시험은 안나오나 중요!!--> new 와 delete는 함수호출이나 계산에 비해 훨씬 오래걸린다.(물론 OS나 input,output이 가장 느리다)

//int main() {
//    Circle* circleArray = new Circle[3];
//    //Circle circleArray[3];
//    circleArray[0].setRadius(10);
//    circleArray[1].setRadius(20);
//    circleArray[2].setRadius(30);
//
//
//    for (int i = 0; i < 3; i++) {
//        cout << "Circle" << i << "의 면적은"<<circleArray[i].getArea()<<endl;
//    }
//    Circle* p = circleArray; // 배열 이름은 주소이므로 포인터에 대입가능. 이때 배열의 이름은 첫 원소의 주소를 가르키고 있다.(참고로 배열의 각 원소들은 연속된다...!)
//    for (int i = 0; i < 3; i++) { //객체 포인터로 배열원소 접근가능
//        cout << "Circle" << i << "의 면적은"<<p->getArea() << endl; // 포인터를 증가시키면 다음 원소를 가르킴
//
//    }
//    delete[] circleArray;
//}


// 동적할당을 활용한 배열
//int main() {
//    cout << "원의 개수: ";
//    int n, radius;
//    cin >> n;
//
//    Circle* pArray = new Circle[n];
//
//    for (int i = 0; i < n; i++) {
//        cout << "원" << i + 1 << ": ";
//        cin >> radius;
//        pArray[i].setRadius(radius);
//    }
//    for (int i = 0; i < n; i++) {
//        cout << "원" << i + 1 << pArray[i].getArea() << endl;
//    }
//    delete[]pArray;
//
//}

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// 메모리 릭(184pg 반드시 출제!!!!)

// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// 실습: Peron의 동적 배열 생성

//class Person {
//private:
//    string name;
//    int age;
//public:
//    Person() {
//        cout << "생성\n";
//    }
//    ~Person() {
//        cout << name << " 소멸\n";
//    }
//    string getName() {
//        return name;
//    }
//    int getAge() {
//        return age;
//    }
//    void set(string n, int a) {
//        name = n;
//        age = a;
//    }
//};
// 
//int main() {
//    cout << "사람 수: ";
//    int n, age;
//    string name;
//
//    cin >> n;
//
//    Person* pArray = new Person[n];
//
//    for (int i = 0; i < n; i++) {
//        cout << "사람" << i + 1 << ": ";
//        cin >> name;
//        cin >> age;
//        pArray[i].set(name, age);
//    }
//    for (int i = 0; i < n; i++) {
//        if (pArray[i].getAge()>=20)
//            cout << "사람" << i + 1 <<": " << pArray[i].getName()<< " " << pArray[i].getAge() << endl;
//    }
//    delete[]pArray;
//
//}


 
// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// this 포인터
    // 필요한 이유: 1. 굳이 필요 없어도, 맴버변수임을 드러내기 위해 혹은 매개변수와 식별자명이 동일할 시 구분하기 위해서. 2. 필수적인 경우(187pg)
    // 연관 개념 참고: 정적멤버 변수와 함수는 붕어빵틀 중 붕어빵 밖에 별도의 것이다. 예를 들어 객체 생성의 횟수의 카운팅을 위한 변수를 정적으로 선언 가능하다. 유사 전역이다(?)


// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// 함수의 인자 전달방식 리뷰(221pg)
void increase(Circle c) {
    int r = c.getRadius();
    c.setRadius(r+1);
}
int main() {
    Circle waffle(30);
    increase(waffle);
    cout << waffle.getRadius() << endl;
}

// 값에 의한 호출은 값복사
// 복사 생성자(??) 개념 확립하기!!